#include "server.h"

user_t user;
int debug = 0;

	static
int dispatch_command(int fd, packet *pkt, char *pkt_body)
{
	switch (pkt->type) {
		case PACKET_AUTH:
			cmd_auth(fd, pkt, (pkt_auth*) pkt_body);
			break;
		case PACKET_REBOOT:
			cmd_reboot(fd, pkt, (pkt_reboot*) pkt_body);
			break;
		default:
			cmd_unknown(fd);
			free(pkt_body);
			return 1;
	}

	return 0;
}

int handle_client(int fd)
{
	packet pkt;
	char *pkt_body;

	user.token = gen_token();
	user.authenticated = 0;

	pkt.magic = 0;
	pkt.token = user.token;
	pkt.type = PACKET_HELLO;
	pkt.size = 0;

	sendlen(fd, (char*)&pkt, sizeof(pkt));

	while (1) {
		recvlen(fd, (char*)&pkt, sizeof(pkt));
		user.magic = pkt.magic;

		if (user.token != pkt.token) {
			cmd_tokenfail(fd);
			return 1;
		}

		pkt_body = xmalloc(pkt.size);
		recvlen(fd, pkt_body, pkt.size);

		if (dispatch_command(fd, &pkt, pkt_body)) {
			return 1;
		}

		pkt_body = xfree(pkt_body, pkt.size);
	}

	return 0;
}

int main(int argc, const char **argv)
{
	int rc;
	int opt;
	int sockfd;
	int clientfd;
	pid_t pid;
	struct sockaddr_in saddr = {0};
	unsigned port = CHALL_PORT;

	if (argc > 1) {
		port = atoi(argv[1]);
	}

	if (signal(SIGCHLD, SIG_IGN) == SIG_ERR) {
		fputs("Failed to set SIGCHLD handler.", stderr);
		return 1;
	}

	sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	if (sockfd == -1) {
		perror("socket");
		return 1;
	}

	opt = 1;

	if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt,
	               sizeof(opt)) != 0) {
		perror("setsockopt");
		return 1;
	}

	saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
	saddr.sin_port = htons(port);

	if (bind(sockfd, (struct sockaddr *) &saddr,
	         sizeof(saddr)) != 0) {
		perror("bind");
		return 1;
	}

	if (listen(sockfd, 20) != 0) {
		perror("listen");
		return 1;
	}

	while (1)
	{
		clientfd = accept(sockfd, NULL, NULL);

		if (clientfd == -1) {
			perror("accept");
			continue;
		}

		pid = fork();

		if (pid == -1) {
			perror("fork");
			close(clientfd);
			continue;
		}

		if (pid == 0) {
			alarm(TIMEOUT);

			close(sockfd);

			rc = drop_privs(CHALL_USER);

			if (rc == 0) {
				rc = handle_client(clientfd);
			}

			close(clientfd);
			_exit(rc);
		}

		close(clientfd);
	}

	return 0;
}

