#include "server.h"

int cmd_fail(int sockfd, char *message, size_t size)
{
	packet pkt;

	pkt.magic = user.magic;
	pkt.token = user.token;
	pkt.type = PACKET_FAIL;
	pkt.size = size;

	sendlen(sockfd, (char*)&pkt, sizeof(pkt));
	sendlen(sockfd, message, size);

	return 0;
}

int cmd_success(int sockfd, char *message, size_t size)
{
	packet pkt;

	pkt.magic = user.magic;
	pkt.token = user.token;
	pkt.type = PACKET_SUCCESS;
	pkt.size = size;

	sendlen(sockfd, (char*)&pkt, sizeof(pkt));
	sendlen(sockfd, message, size);

	return 0;
}

int cmd_auth(int sockfd, packet *pkt, pkt_auth *auth)
{
	char *username;
	char *password;
	char hash[SHA512_DIGEST_LENGTH];
	char buf[80];
	char flag[150];
	ssize_t flag_len = 0;
	char *refhash = NULL;
	size_t size;
	int fd;
	packet response;
	int res;

	username = (char*)&auth->data;
	password = (char*)&auth->data + auth->login_size;

	if ((fd = open(CREDS_DB, O_RDONLY)) != -1) {
		do {
			size = read(fd, buf, sizeof(buf));

			if (!strncmp(username, buf, auth->login_size)) {
				refhash = buf + 16;
				break;
			}
		} while (size == sizeof(buf));

		if (refhash) {
			SHA512((const unsigned char*)password,
			       auth->password_size,
			       (unsigned char*)hash);

			if (!strncmp(hash, refhash, 64)) {
				user.authenticated = 1;
			}
		}

		close(fd);
	}

	response.magic = user.magic;
	response.token = user.token;
	response.type = PACKET_AUTH;
	response.size = sizeof(res);

	if (user.magic == MAGIC_WORD) {
		if (user.authenticated) {
			res = 2;

			if ((fd = open(FLAG_PART_1, O_RDONLY)) != -1) {
				flag_len = read(fd, flag, sizeof(flag));
				response.size += flag_len;
			}
		} else {
			res = 0;
		}
	} else {
		res = 1;
	}

	sendlen(sockfd, (char*)&response, sizeof(response));
	sendlen(sockfd, (char*)&res, sizeof(res));

	if (res == 2) {
		sendlen(sockfd, flag, flag_len);
	}

	return res;
}

static
void do_reboot(backup_infos *backup)
{
	struct stat sb;

	fstat(backup->in_fd, &sb);
	sendfile(backup->out_fd, backup->in_fd, 0, sb.st_size);
}

int cmd_reboot(int sockfd, packet *pkt, pkt_reboot *reboot)
{
	backup_infos backup;
	char *msg = (char*)&reboot->message;

	if (pkt->size >= sizeof(backup.message)) {
		return cmd_fail(sockfd, MSG_TOO_LONG, sizeof(MSG_TOO_LONG));
	}

	memset(&backup, 0, sizeof(backup));

	if ((backup.in_fd = open(CREDS_DB, O_RDONLY)) != -1 &&
	    (backup.out_fd = open(DEVNULL, O_WRONLY)) != -1) {

		memcpy(backup.message, REBOOT_PREFIX, sizeof(REBOOT_PREFIX));
		memcpy(backup.message + sizeof(REBOOT_PREFIX), msg, pkt->size);

		do_reboot(&backup);
		cmd_success(sockfd, BACKUP_SUCCESS, sizeof(BACKUP_SUCCESS));
	} else {
		fputs(BACKUP_FAIL, stderr);
		cmd_fail(sockfd, BACKUP_FAIL, sizeof(BACKUP_FAIL));
	}

	close(backup.in_fd);
	close(backup.out_fd);

	return 0;
}

int cmd_unknown(int sockfd)
{
	return cmd_fail(sockfd, UNKNOWN_COMMAND, sizeof(UNKNOWN_COMMAND));
}

int cmd_tokenfail(int sockfd)
{
	return cmd_fail(sockfd, INVALID_TOKEN, sizeof(INVALID_TOKEN));
}
